
    {
      "port": <%= process.env.MOCK_MQ_PORT || 3002 %>,
      "protocol": "http",
      "name": "Mock IBM MQ Server",
      "recordRequests": <%= process.env.MOCK_MQ_RECORD_REQUESTS !== 'false' %>,
      "stubs": [
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/send"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockSend(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/receive"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockReceive(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/browse"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockBrowse(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/queue/depth"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockDepth(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        <%# Legacy depth endpoint for backward compatibility %>
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/depth"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockDepth(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/health"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockHealth(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 500) + 500 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/queue/list"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockList(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        <%# Legacy queues endpoint for backward compatibility %>
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/queues"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockList(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/queue/create"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockCreate(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1500 %>"
              }
            }
          ]
        },
        <%# Legacy queues endpoint for backward compatibility %>
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/queues"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockCreate(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1500 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "DELETE",
                "path": "/mq/queue/delete"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockClear(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        <%# Legacy clear endpoint for backward compatibility %>
        {
          "predicates": [
            {
              "equals": {
                "method": "DELETE",
                "path": "/mq/clear"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockClear(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/status"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockStatus(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 500) + 500 %>"
              }
            }
          ]
        },
        <%# Connection management endpoints %>
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/connect"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { return { statusCode: 200, headers: { 'Content-Type': 'application/json' }, body: { status: 'SUCCESS', operation: 'CONNECT', message: 'Connected to mock queue manager', queueManager: config.request.body?.queueManager || 'MOCK_QM1', timestamp: new Date().toISOString() } }; }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/disconnect"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { return { statusCode: 200, headers: { 'Content-Type': 'application/json' }, body: { status: 'SUCCESS', operation: 'DISCONNECT', message: 'Disconnected from mock queue manager', timestamp: new Date().toISOString() } }; }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 500) + 500 %>"
              }
            }
          ]
        }<% if (process.env.MOCK_MQ_ENABLE_ADMIN === 'true') { %>,
        <%# Admin endpoints (only enabled if MOCK_MQ_ENABLE_ADMIN=true) %>
        {
          "predicates": [
            {
              "equals": {
                "method": "POST",
                "path": "/mq/admin/reset"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockReset ? middleware.mockReset(config.request) : { statusCode: 501, headers: { 'Content-Type': 'application/json' }, body: { status: 'ERROR', message: 'Reset function not implemented' } }; }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1500 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/mq/admin/stats"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockStats ? middleware.mockStats(config.request) : { statusCode: 501, headers: { 'Content-Type': 'application/json' }, body: { status: 'ERROR', message: 'Stats function not implemented' } }; }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 500) + 500 %>"
              }
            }
          ]
        }<% } %>
      ]
    }<% if (process.env.MOCK_MQ_ENABLE_MGMT_PORT === 'true') { %>,
    <%# Management interface on separate port (only if enabled) %>
    {
      "port": <%= process.env.MOCK_MQ_MGMT_PORT || 3003 %>,
      "protocol": "http",
      "name": "Mock IBM MQ Management Interface",
      "recordRequests": false,
      "stubs": [
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/status"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { return { statusCode: 200, headers: { 'Content-Type': 'application/json' }, body: { status: 'HEALTHY', service: 'Mock IBM MQ Management', version: '1.0.0', timestamp: new Date().toISOString() } }; }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 300) + 200 %>"
              }
            }
          ]
        },
        {
          "predicates": [
            {
              "equals": {
                "method": "GET",
                "path": "/queues"
              }
            }
          ],
          "responses": [
            {
              "inject": "function(config) { const path = require('path'); const middleware = require(path.join(process.cwd(), 'lib', 'mq', 'mq-bridge-middleware')); return middleware.mockList(config.request); }",
              "_behaviors": {
                "wait": "<%= Math.floor(Math.random() * 1000) + 1000 %>"
              }
            }
          ]
        }
      ]
    }<% } %>
